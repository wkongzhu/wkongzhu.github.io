<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>蒙哥马利算法</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">蒙哥马利算法</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 综述</a></li>
<li><a href="#sec-2">2. 基本概念</a></li>
<li><a href="#sec-3">3. 蒙哥马利预备知识</a></li>
<li><a href="#sec-4">4. 蒙哥马利约减</a></li>
<li><a href="#sec-5">5. 蒙哥马利乘模</a></li>
<li><a href="#sec-6">6. 蒙哥马利幂模</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 综述</h2>
<div class="outline-text-2" id="text-1">
<p>
这篇文章为大家梳理一下整个蒙哥马利算法的本质，蒙哥马利算法并不是一个独立的算法，
而是三个相互独立又相互联系的算法集合，其中包括
</p>

<ol class="org-ol">
<li>蒙哥马利乘模，是用来计算\(x\cdot y\ (mod\ N)\)
</li>
<li>蒙哥马利约减，是用来计算\(t\cdot \rho^{-1}\ (mod\ N)\)
</li>
<li>蒙哥马利幂模，是用来计算\(x^y\ (mod\ N)\)
</li>
</ol>

<p>
其中蒙哥马利幂模是RSA加密算法的核心部分。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 基本概念</h2>
<div class="outline-text-2" id="text-2">
<p>
梳理几个概念，试想一个集合是整数模N之后得到的
$$Z_N=\left\{0,1,2,\cdots,N-1\right\}$$
</p>

<p>
注意：N在base-b进制下有 \(l_N\) 位。 比如10进制和100进制，都属于 \(base-10\) 进制，因为 \(100=10^2\), 所以b=10。在10进制下，
667的 \(l_N=3\)
</p>

<p>
这样的集合叫做N的剩余类环，任何属于这个集合 \(Z_n\) 的x满足以下两个条件：
</p>

<ol class="org-ol">
<li>是正整数
</li>
<li>最大长度是 \(l_N\)
</li>
</ol>

<p>
这篇文章中讲到的蒙哥马利算法就是用来计算基于 \(Z_N\) 集合上的运算, 简单讲一下原因，因为RSA是基于大数运算的，
通常是1024bit或2018bit，而我们的计算机不可能存储完整的大数，因为占空间太大，而且也没必要。
因此，这种基于大数运算的加密体系在计算的时候都是基于 \(Z_N\) 集合的，自然，蒙哥马利算法也是基于 \(Z_N\).
</p>

<p>
在剩余类环上，有两种重要的运算，一类是简单运算，也就是加法和减法，
另一类复杂运算，也就是乘法。我们比较熟悉的是自然数集上的运算，
下面看下怎么从自然数集的运算演变成剩余类环上的运算。
</p>

<ul class="org-ul">
<li>对于加法运算，如果计算 \(x\pm y\ (mod\ N), (0\leqslant x,y \lt N)\)
试想自然数集上的 \(x\pm y\),
$$\qquad 0\leqslant x+y\leqslant 2\cdot(N-1)$$
$$-(N-1)\leqslant x-y\leqslant (N-1)$$

<p>
我们可以简单的通过加减N来实现从自然数到剩余类集的转换
</p>
</li>

<li>另外一类是乘法操作，也就是 \(x\cdot y\ (mod\ N), (0\leqslant x,y\lt N)\), 那么

<p>
\(0\leqslant x\cdot y\leqslant (N-1)^2\)
</p>

<p>
如果在自然数集下，令 \(t=x\cdot y\), 那么对于 \(\mod N\) 我们需要计算
$$t-（N\cdot \lfloor\frac{t}{N}\rfloor）$$
</p>

<p>
加减操作很简单，具体的算这里就不细说了，我们用 \((Z_N-ADD)\) 来代表剩余类环上的加法操作。
既然我们可以做加法操作，那么我们就可以扩展到乘法操作，算法如下
</p>
</li>
</ul>


<div class="figure">
<p><img src="/img/r01.jpg" alt="r01.jpg" width="600" />
</p>
</div>

<p>
但是这并不是一个好的解决方案，因为通常来说，我们不会直接做w位乘w位的操作，这个后面会用蒙哥马利的乘法来代替解决。
</p>

<p>
对于取模操作，一般有以下几种方法
</p>

<ol class="org-ol">
<li>根据以下公式，来计算取模操作
\(t-（N\cdot \lfloor\frac{t}{N}\rfloor）\)
这种解法有以下特征

<p>
整个计算过程是基于标准的数字表示
不需要预计算（也就是提前计算一些变量，以备使用）
涉及到一个除法操作，非常费时和复杂
</p>
</li>
<li>用Barrett reduction算法，这篇文章不细说，但是有以下特征
基于标准的数字表示
不需要预计算
需要 \(2 \cdot (l_N+1) \cdot (l_N+1)\) 次数乘运算
</li>
<li>用蒙哥马利约减，也就是下面要讲的算法，有以下特征
不是基于标准的数字表示（后文中有提到，是基于蒙哥马利表示法）
需要预计算,
共\(2 \cdot (l_N) \cdot (l_N)\) 次数乘运算
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 蒙哥马利预备知识</h2>
<div class="outline-text-2" id="text-3">
<p>
在将蒙哥马利算法之前，先看一下在自然数下的乘法公式
</p>

<p>
计算 \(x\cdot y\), 想象一下我们常用的计算乘法的方法，用乘数的每一位乘上被乘数，然后把得到的结果相加，总结成公式，可以写成如下的形式。
</p>

<p>
\(x\cdot y=x\cdot \sum_{i=0}^{l_y-1}y_i \cdot b^i\)
</p>

<p>
\(\qquad=\sum_{i=0}^{l_y-1}y_i \cdot x \cdot b^i\)
</p>

<p>
尝试下面一个例子，10进制下（也就是b=10），y=456（也就是 \(l_n=3\) ）,计算 \(x\cdot y\), 公式可演变如下：
</p>

<p>
$$x\cdot y=(y_{0}\cdot x\cdot 10^{0})+(y_{1}\cdot x\cdot 10^{1})+(y_{2}\cdot x\cdot 10^{2})$$
$$\qquad=(y_{0}\cdot x\cdot 0)+(y_{1}\cdot x\cdot 10)+(y_{2}\cdot x\cdot 100)$$
$$\qquad=(y_{0}\cdot x)+10\cdot(y_{1}\cdot x+10\cdot(y_{2}\cdot x\cdot +10\cdot(0)))$$
</p>

<p>
最后一次演变其实就是用霍纳法则(<b>Horner’s rule</b>)所讲的规则，关于霍纳法则，可以自行百度。
</p>

<p>
这个计算过程写成代码实现的算法应该是这样的：
</p>


<div class="figure">
<p><img src="/img/r02.jpg" alt="r02.jpg" width="600" />
</p>
</div>

<p>
接下来我们来看下面这样的计算，计算 \((x\cdot y)/1000\), 由前面可以知道
$$x\cdot y=(y_{0}\cdot x)+10\cdot(y_{1}\cdot x+10\cdot(y_{2}\cdot x\cdot +10\cdot(0)))$$
</p>

<p>
由此可以知道：
</p>

<p>
$$\frac{x\cdot y}{1000}=\frac{(y_{0}\cdot x\cdot 10^{0})+(y_{1}\cdot x\cdot 10^{1})+(y_{2}\cdot x\cdot 10^{2})}{1000}$$
</p>

<p>
$$\qquad=\frac{(y_{0}\cdot x\cdot 0)+(y_{1}\cdot x\cdot 10)+(y_{2}\cdot x\cdot 100)}{1000}$$
</p>

<p>
$$\qquad=\frac{(y_{0}\cdot x)}{1000}+\frac{(y_{1}\cdot x)}{100}+\frac{(y_{2}\cdot x)}{10}$$
</p>

<p>
$$\qquad=(((((y_0\cdot x)/10)+y_1\cdot x)/10)+y_2\cdot x)/10$$
</p>

<p>
这个计算过程写成代码实现的算法是这样的：
</p>


<div class="figure">
<p><img src="/img/r03.jpg" alt="r03.jpg" width="600" />
</p>
</div>

<p>
接下来我们再来看在剩余类集合下的乘法操作 \(x\cdot y/1000\ (mod\ 667)\)
</p>

<p>
我们知道剩余类集合 \(Z_{667}=\left\{0,1 \cdots 666\right\}\), 是不存在小数的, 而如果我们采用自然数集的计算方式的话,
就会出现小数, 比如前面的例子, 除10就会有小数。
</p>

<p>
这个问题是这样的, 我们知道 \(u·667 \equiv 0\ (mod\ 667)\) （\(\equiv\) 表示取模相等）,
所以我们可以选择一个合适的 \(u\), 用 \(u\) 乘667再加上 \(r\), 使得 <b>和</b> 可以被10整除, 这样在 \(mod\ 667\) 之后依然是正确的结果。
至于 \(u\) 怎么算出来, 这篇文章会在后面的章节说明。
</p>

<p>
这个过程之后 \(x\cdot y/1000\ (mod\ 667)\) 的计算算法可以写成如下的形式(\(N=667\))
</p>


<div class="figure">
<p><img src="/img/r04.jpg" alt="r04.jpg" width="600" />
</p>
</div>

<p>
至此, 你可能还不明白上面说这一堆演变的原因, 其实很简单, 原来是一个 \((x\cdot y)\ (mod\ 667)\) 的运算,
这个运算中的模操作, 正常情况下是要通过除法实现的, 而除法是一个特别复杂的运算, 要涉及到很多乘法,
所以在大数运算时, 我们要尽量避免除法的出现。而通过以上几个步骤, 我们发现 \((x\cdot y)/1000\ (mod\ 667)\),
这个操作是不用除法的。等等, 算法中明明有个除10的操作, 你骗谁呢。不知道你有没有发现,
除数其实是我们的进制数, 除进制数在计算机中是怎么做呢, 其实很简单, 左移操作就ok了。所以这个计算方法是不涉及到除法操作的。
</p>

<p>
但是我们要计算的明明是 \((x_1\cdot y_1)\ (mod\ 667)\), 怎么现在变成了 \((x_2\cdot y_2)/1000\ (mod\ 667)\),
所以在下一步, 我们要思考的是怎么样让 \((x_1\cdot y_1)\ (mod\ 667)\) 转变成 \((x_2\cdot y_2)/1000\ (mod\ 667)\) 这种形式。
</p>

<p>
考虑这样两个算法
</p>

<ul class="org-ul">
<li>第一个是输入 \(x\) 和 \(y\), 计算 \(x \cdot y \cdot \rho^{-1}\)
</li>
<li>第二个算法, 输入一个 \(t\), 计算 \(t \cdot \rho^{-1}\)
   $$x\cdot y\ (mod\ 667)=((x\cdot1000)\cdot(y\cdot1000)/1000)/1000\ (mod\ 667)$$
</li>
</ul>

<p>
是不是变成了我们需要的 \((x\cdot y)/1000\ (mod\ 667)\) 模式, 而且这个转变过程是不是可以通过上面两个算法来实现,
输入值如果是 \((x\cdot1000)\) 和 \((y\cdot1000)\), 则通过第一个算法可以得到 \(((x\cdot1000)\cdot(y\cdot1000)/1000)\),
把结果作为第二个算法的输入值, 则通过第二个算法可以得到 \(((x\cdot1000)\cdot(y\cdot1000)/1000)/1000\).
</p>

<p>
扯了一大顿, 终于引出了今天文章的主角, 前面讲到的两个算法, 第一个就是蒙哥马利乘模, 第二个就是蒙哥马利约减。
下面我们来讲这两个算法的详解。
</p>

<p>
正如前面提到的蒙哥马利算法的三个特性之一是, 不是基于普通的整数表示法, 而是基于蒙哥马利表示法。
什么是蒙哥马利表示法呢, 其实也很简单, 上面我们提到,
要让 \((x_1\cdot y_1)\ (mod\ 667)\) 转变成 \((x_2\cdot y_2)/1000\ (mod\ 667)\) 这种形式,
我们需要将输入参数变成 \((x\cdot1000)\) 和 \((y\cdot1000)\), 而不是x和y本身,
而 \((x\cdot1000)\) 和 \((y\cdot1000)\) 其实就是蒙哥马利表示法。
</p>

<p>
所以我们先定义几个概念：
</p>

<dl class="org-dl">
<dt> 蒙哥马利参数 </dt><dd>  给定一个 \(N\), \(N\) 在b进制（例如, 二进制时, b=2）下共有 \(l_N\) 位, \(gcd(N,b)=1\),
先预计算以下几个值(这就是前面提到的特性之一, 需要预计算）：
\(\rho = b^k\) 指定一个最小的 \(k\), 使得 \(b^k>N\).
\(\omega = -N^{-1} (mod\ \rho)\)

<p>
这两个参数是做什么用的呢, 你对照前面的演变过程可以猜到 \(\rho\) 就是前面演变中的 \(1000\), 而 \(\omega\)
则是用来计算前面提到的 \(u\) 的。
</p>
</dd>

<dt> 蒙哥马利表示法 </dt><dd>  对于 \(x\), \(0\leqslant x\leqslant N-1\), \(x\) 的蒙哥马利表示法表示为 \(x=x\cdot \rho\ (mod\ N)\)
</dd>
</dl>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 蒙哥马利约减</h2>
<div class="outline-text-2" id="text-4">
<p>
蒙哥马利约减的定义如下:
</p>

<p>
给定一些整数 \(t\), 蒙哥马利约减的计算结果是 \(t\cdot \rho^{-1}\ (mod\ N)\)
</p>

<p>
蒙哥马利约减的算法可表示为
</p>


<div class="figure">
<p><img src="/img/r05.jpg" alt="r05.jpg" width="600" />
</p>
</div>

<p>
蒙哥马利约减可以算作是下面要说的蒙哥马利模乘当 \(x=1\) 时的一种特殊形式,
同时它又是蒙哥马利乘模要用到的一部分, 这在下一部分讲蒙哥马利乘模的时候有讲到。
</p>

<p>
蒙哥马利约减可以用来计算某个值得取模操作, 比如我们要计算 \(m(mod\ N)\), 只需要将 \(m\)
的蒙哥马利表示法 \(m\cdot \rho\) 作为参数, 带入蒙哥马利约减, 则计算结果就是 \(m(mod\ N)\).
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 蒙哥马利乘模</h2>
<div class="outline-text-2" id="text-5">
<p>
一个蒙哥马利乘模包括整数乘法和蒙哥马利约减, 现在我们有蒙哥马利表示法：
</p>

<p>
$$\hat{x}=x\cdot\rho\ (mod\ N)$$
$$\hat{y}=y\cdot\rho\ (mod\ N)$$
</p>

<p>
它们相乘的结果是
</p>

<p>
$$t=\hat{x}\cdot\hat{y}$$
$$\ =(x\cdot\rho)\cdot(y\cdot\rho)$$
$$\ =(x\cdot y)\cdot\rho^2$$
</p>

<p>
最后, 用一次蒙哥马利约减得到结果
</p>

<p>
$$\hat{t}=(x \cdot y) \cdot \rho\ (mod\ N)$$
</p>

<p>
上面我们可以看出, 给出的输入参数是 \(\hat{x}\) 和 \(\hat{y}\),  得到的结果是 \((x \cdot y) \cdot \rho\ (mod\ N)\),
所以蒙哥马利乘法也可以写成如下形式, 已知输入参数x和y, 蒙哥马利乘法是计算 \((x \cdot y) \cdot \rho ^ {-1}\ (mod\ N)\)
</p>

<p>
举个例子：
b=10, 也就是说在10进制下, N=667
让 \(b^k>N\) 的最小的k是3, 所以 \(\rho=b^k=10^3=1000\)
$$\omega=-N^{-1}\ (mod\ \rho)=-667^{-1}\ (mod\ \rho)=997$$
如果使用数学软件 <b>GAP</b>, 用如下指令可以得到：
</p>
<div class="org-src-container">

<pre class="src src-pascal"><span class="linenr">1: </span>N := ZmodnZObj(667, 1000);
<span class="linenr">2: </span>w := Int(-N^-1);
</pre>
</div>

<p>
因为 \(x=421\), 所以 \(\hat{x}=x\cdot\rho(mod\ N)=421\cdot1000(mod\ 667)=123\)
</p>

<p>
因为 \(y=422\), 所以 \(\hat{y}=y\cdot\rho(mod\ N)=422\cdot1000(mod\ 667)=456\)
</p>

<p>
所以计算 \(\hat{x}\) 和 \(\hat{y}\) 蒙哥马利乘结果是
</p>

<p>
$$\hat{x}\cdot\hat{y}\cdot\rho^{-1}=(421\cdot1000\cdot422\cdot1000)\cdot1000^{-1}\ (mod\ 667)$$
$$\qquad\qquad(421\cdot422)\cdot1000\ (mod\ 667)$$
$$\qquad\qquad(240)\cdot1000\ (mod\ 667)$$
$$\qquad\qquad547\ (mod\ 667)$$
</p>

<p>
然后总结一下蒙哥马利约减和蒙哥马利乘法的伪代码实现, 这个算法其实就是从蒙哥马利预备知识讲到的算法演变来的。
</p>


<div class="figure">
<p><img src="/img/r06.jpg" alt="r06.jpg" width="600" />
</p>
</div>


<p>
上面的例子用这个算法可以描述为:(注： 下图中&lt;1,2,3,4&gt;表示整数4321）
</p>


<div class="figure">
<p><img src="/img/r07.jpg" alt="r07.jpg" width="1000" />
</p>
</div>


<p>
蒙哥马利算法是一套很完美的算法, 为什么这么说呢, 你看一开始已知 \(x\), 我们要求 \(\hat{x}=x \cdot \rho\),
这个过程可以通过蒙哥马利乘法本身来计算, 输入参数 \(x\) 和 \(\rho^2\), 计算结果就是 \(\hat{x}=x \cdot \rho\).
然后在最后, 我们知道 \(\hat{x}=x \cdot \rho\), 要求得 \(x\) 的时候,
同样可以通过蒙哥马利算法本身计算, 输入参数 \(\hat{x}\) 和 \(1\), 计算结果就是 \(x\).
有没有一种因就是果, 果就是因的感觉, 这就是为什么说蒙哥马利算法是一套很完美的算法。
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 蒙哥马利幂模</h2>
<div class="outline-text-2" id="text-6">
<p>
最后, 才说到我们最开始提到的RSA的核心幂模运算, 先来看一下普通幂运算的算法是怎么得出来的。
</p>

<p>
以下资料来自于百度百科快速模幂运算
针对快速模幂运算这一课题, 西方现代数学家提出了大量的解决方案, 通常都是先将幂模运算转化为乘模运算。
例如求 \(D=C^{15}\ \mod\ N\)
由于：\((a*b)\ mod\ n = (a\ mod\ n) * (b\ mod\ n)\ mod\ n\)
</p>

<p>
所以令：
$$C1 =C*C \ mod\  N =C^2 \ mod\  N$$
$$C2 =C1*C \ mod\  N =C^3 \ mod\  N$$
$$C3 =C2*C2 \ mod\  N =C^6 \ mod\  N$$
$$C4 =C3*C \ mod\  N =C^7 \ mod\  N$$
$$C5 =C4*C4 \ mod\  N =C^{14} \ mod\  N$$
$$C6 =C5*C \ mod\  N =C^{15} \ mod\  N$$
</p>


<p>
即：对于E=15的幂模运算可分解为6个乘模运算, 归纳分析以上方法可以发现：
</p>

<p>
对于任意指数 \(E\), 都可采用以下算法计算 \(D=C^E\ mod\ N\)
</p>

<div class="org-src-container">

<pre class="src src-python"><span class="linenr">1: </span><span style="color: #eedd82;">D</span> = 1
<span class="linenr">2: </span><span style="color: #00ffff;">while</span> E&gt;0 :
<span class="linenr">3: </span>   <span style="color: #00ffff;">if</span> E % 2 ==0 :
<span class="linenr">4: </span>       <span style="color: #eedd82;">C</span> = C*C % N
<span class="linenr">5: </span>       <span style="color: #eedd82;">E</span> = E/2
<span class="linenr">6: </span>   <span style="color: #00ffff;">else</span> :
<span class="linenr">7: </span>       <span style="color: #eedd82;">D</span> = D*C % N
<span class="linenr">8: </span>       <span style="color: #eedd82;">E</span> = E-1
<span class="linenr">9: </span><span style="color: #00ffff;">return</span> D
</pre>
</div>

<p>
继续分析会发现, 要知道 E 何时能整除2, 并不需要反复进行减一或除二的操作, 只需验证 E 的二进制各位是0还是1就可以了,
从左至右或从右至左验证都可以, 从左至右会更简洁,
</p>

<p>
设 \(E=\sum_{i=0}^{n} E_i*2^i, E_i=0,1\)
</p>
<div class="org-src-container">

<pre class="src src-python"><span class="linenr">1: </span><span style="color: #eedd82;">D</span> = 1
<span class="linenr">2: </span><span style="color: #00ffff;">for</span> <span style="color: #eedd82;">i</span>=n to 0 :
<span class="linenr">3: </span>    <span style="color: #eedd82;">D</span> = D*D % N
<span class="linenr">4: </span>    <span style="color: #00ffff;">if</span> Ei ==1 :
<span class="linenr">5: </span>       <span style="color: #eedd82;">D</span> = D*C % N
<span class="linenr">6: </span><span style="color: #00ffff;">return</span> D
</pre>
</div>

<p>
这样, 模幂运算就转化成了一系列的模乘运算。
</p>

<p>
算法可以写成如下的形式
</p>


<div class="figure">
<p><img src="/img/r08.jpg" alt="r08.jpg" width="600" />
</p>
</div>

<p>
如果我们现在用蒙哥马利样式稍作改变, 就可以变成如下的形式：
</p>


<div class="figure">
<p><img src="/img/r09.jpg" alt="r09.jpg" width="600" />
</p>
</div>

<p>
以上就是蒙哥马利算法的全部, 通过蒙哥马利算法中的约减运算, 我们将大数运算中的模运算变成了移位操作, 极大地提高了大数模乘的效率。
</p>

<p>
但是在以上的算法, 可以发现还有两个变量的计算方式不是很清楚, 一个是 \(\omega\), 前面说过 \(\omega = -N^{-1} (mod \rho)\),
其实在算法中, 我们看到, \(\omega\) 仅仅被用来做 \(\mod b\) 操作, 所以事实上, 我们只需要计算 \(\mod b\) 即可.
</p>

<p>
尽管N是合数（因为两个素数的乘积不是素数）, 但N和 \(\rho\) （也就是N和b）必须是互质的,
也就是说 \(N^{\phi(b)}=1(mob\ b)\) (费马定理), \(N^{\phi(b)-1}=N^{-1}(mod\ b)\)
因为 \(b=2^\omega\), 所以 \(\phi(b)=2^{(\omega-1)}\), 写成算法是这样的
</p>


<div class="figure">
<p><img src="/img/10.jpg" alt="r10.jpg" width="600" />
</p>
</div>

<p>
还有一个参数是 \(\rho^2\), 还记得前面说过 \(\rho\) 是怎么得出来吗, 选定一个最小的 \(k\), 使得 \(b^k>N\),
我们还知道 \(N\) 在 \(b\) 进制下是 \(l_N\) 位, 所以当 \(k=l_N\) 的时候肯定是符合要求。
</p>

<p>
\(b=2^{\omega}\) 所以\(\rho=b^k=({2^{\omega}})^k\)
</p>

<p>
\(\rho^2={({2^w})^k)}^2=2^{2\cdot k\cdot \omega}=2^{2\cdot l_N\cdot \omega}\), 算法如下
</p>


<div class="figure">
<p><img src="/img/11.jpg" alt="r11.jpg" width="600" />
</p>
</div>

<p>
至此整个蒙哥马利算法就全部说完了。通过这个算法, 我们可以实现快速幂模。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="validation"></p>
</div>
</body>
</html>
